# DOLAR QUOTATION WEBSCRAP TEST - GABRIEL SOUZA

#Importing useful libraries
import selenium #powefull and user friendly library for the webscrap
from selenium import webdriver
import datetime #already helped me a lot at timeseries analisys!
from datetime import date
from datetime import timedelta 
from datetime import datetime
import time #works but can be replaced by Selenium fluentwait. I still need to get used to this
import pandas as pd #what could we do without pandas, doh!
import xlsxwriter #best writer. Very intuitive (when not in pandas)

#Getting last months days as a list that we will use as input at the scrap cell.
#Please note that this should be a function in a more scalable code. 
#But since the goal here is to find last month only, the list generation works faster.
#Please note also that if the notebook got inspected after August month, instead of a lists of July days, it will return a list of August days.
#The quest sheet specifically asked for "Last month, i.e. July"
m = datetime.now().month
y = datetime.now().year
ndays = (date(y, m, 1) - date(y, m-1, 1)).days
d1 = date(y, m-1, 1)
d2 = date(y, m-1, ndays)
delta = d2 - d1

last_month_days = [(d1 + timedelta(days=i)).strftime('%d/%m/%Y') for i in range(delta.days + 1)]


#Here we're diving into the quest. This cell goes through the webdriver. I used the base of B3 scrap I daily use
driver = webdriver.Firefox() #Firefox because we care about privacy, ok google?
time.sleep(5) #can be optimized with fluentwait
driver.get('https://www.bcb.gov.br/')
time.sleep(5)
#getting into the right page through the frontpage, as quest requested.
element = driver.find_element_by_xpath('/html/body/app-root/app-root/main/dynamic-comp/div/div/div/div[1]/div[2]/div/conversormoedas/div[2]/a').click()
time.sleep(5)
quotation_date = [] #list to be filled with dates - tricky thing once you need to deal with globals companies calendars, where not necessarilly hollidays and weekends are not work days
brlusd = [] #list to be filled with the quotation itself
for day in last_month_days: #iterating at the list we created at previous cell
    element = driver.find_element_by_xpath('//*[@id="dataMask"]') 
    element.clear()
    element.send_keys(day)
    element.send_keys('\ue007')
    element.send_keys('\ue007') #Tricky stuff again. If you just hit one "enter", it swap base and target countries. Fast way is to hit two "enters" in a row.
    time.sleep(1)
    str_quotation = driver.find_element_by_xpath('/html/body/app-root/app-root/main/dynamic-comp/div/bcb-pagina-tipo0/div/bcb-pagina-tipo4/div[2]/div/dynamic-comp/div/div/bcb-detalhesconversor/div/div[2]/div/div[1]/div[2]/div').text
    #For God sake I couldn't get to the right Xpath for the quotation string itself. That leaded to the whole block scrap and a quick string manipulation. This REALLY pissed me off and must be updated in a scalable code
    edited_quotation = str_quotation.split(':')[2]
    edited_quotation = edited_quotation.replace(' ', '')
    edited_quotation = edited_quotation.replace(',', '.') #babysteps at string editing. Always the best way
    brlusd.append(edited_quotation)
    #Another tricky way to correctly use the date. You can see that when we're not at working days, the date is atmatically swaped. Best way to avoid errors is to download the date generated by the webpage
    date = driver.find_element_by_xpath('/html/body/app-root/app-root/main/dynamic-comp/div/bcb-pagina-tipo0/div/bcb-pagina-tipo4/div[2]/div/dynamic-comp/div/div/bcb-detalhesconversor/div/div[2]/div/div[2]').text
    edited_date = date.split(':')[1]
    edited_date = edited_date[1:11] #babysteps again. Errorproof.
    quotation_date.append(edited_date)
    time.sleep(1)
driver.quit()

#Getting thw workbook together
workbook = xlsxwriter.Workbook('july_brlusd.xlsx') #more scalable code, if necessary, should use the month of strftime for the sheet naming.
worksheet = workbook.add_worksheet('july_quotation') #more scalable code, if necessary, should use the month of strftime for the sheet naming.
header = ['date', 'brlusd']
worksheet.write(0, 0, header[0])
worksheet.write(0, 1, header[1])
row=0
for day in quotation_date:
    worksheet.write(row+1,0,day)
    row=row+1
row=0
for quotation in brlusd:
    worksheet.write(row+1,1,quotation)
    row=row+1
workbook.close()

#Reading the workbook
july_brlusd_quotation = pd.read_excel('july_brlusd.xlsx', sheet_name='july_quotation', names=header ) #More scalable solution would require OSpath
july_brlusd_quotation = july_brlusd_quotation.drop_duplicates() #Non workdays generated duplicated lines. Let's get rid of it

#Making sure all formates are correct, just in case...
july_brlusd_quotation['brlusd'].apply(lambda x: float(x)).inplace=True
july_brlusd_quotation['date'] = pd.to_datetime(july_brlusd_quotation['date'], format='%d/%m/%Y')

#Although the quest sheet requested to "calculate min, max and mean values", describe function does it very quickly and in a callable way
stats = july_brlusd_quotation.describe()
stats = stats.transpose()
printable = []
print_stats = ['min', 'max', 'mean', '50%']
for stat in print_stats:
    value = stats.loc['brlusd', stat]
    line = '%s value is %.4f' %(stat, value)
    printable.append(line)
printable
